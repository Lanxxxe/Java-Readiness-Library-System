<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/Academic.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Academic.java" />
              <option name="originalContent" value="public class Academic extends LibraryUser {&#10;&#10;    public Academic(String name) {&#10;        super(name);&#10;    }&#10;&#10;    @Override&#10;    public int getLoanPeriodForItem(LibraryItem item) {&#10;        if (item == null) {&#10;            throw new IllegalArgumentException(&quot;Item cannot be null&quot;);&#10;        }&#10;        &#10;        if (item instanceof Magazine) {&#10;            return 28; // Academics get 28 days for magazines&#10;        } else if (item instanceof DVD) {&#10;            return 21; // Academics get 21 days for DVDs&#10;        } else if (item instanceof Book) {&#10;            return 35; // Academics get 35 days for books (including ReferenceOnlyBook)&#10;        } else {&#10;            return 14; // Default period for any other item types&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public int getLoanLimit() {&#10;        return 10; // Academics can borrow up to 10 items&#10;    }&#10;&#10;    @Override&#10;    public double getFineRateModifier() {&#10;        return 1.0; // Academics pay the standard fine rate&#10;    }&#10;&#10;    @Override&#10;    public double getFineSuspensionLimit() {&#10;        return 20.0; // Academics are suspended when fines reach $20&#10;    }&#10;&#10;    @Override&#10;    public String getUserRole() {&#10;        return &quot;Academic&quot;;&#10;    }&#10;}" />
              <option name="updatedContent" value="public class Academic extends LibraryUser {&#10;&#10;    public Academic(String name) {&#10;        super(name);&#10;    }&#10;&#10;    @Override&#10;    public int getLoanPeriodForItem(LibraryItem item) {&#10;        if (item == null) {&#10;            throw new IllegalArgumentException(&quot;Item cannot be null&quot;);&#10;        }&#10;        &#10;        if (item instanceof Magazine) {&#10;            return 28; // Academics get 28 days for magazines&#10;        } else if (item instanceof DVD) {&#10;            return 21; // Academics get 21 days for DVDs&#10;        } else if (item instanceof Book) {&#10;            return 35; // Academics get 35 days for books (including ReferenceOnlyBook)&#10;        } else {&#10;            return 14; // Default period for any other item types&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public int getLoanLimit() {&#10;        return 10; // Academics can borrow up to 10 items&#10;    }&#10;&#10;    @Override&#10;    public double getFineRateModifier() {&#10;        return 1.0; // Academics pay the standard fine rate&#10;    }&#10;&#10;    @Override&#10;    public double getFineSuspensionLimit() {&#10;        return 20.0; // Academics are suspended when fines reach $20&#10;    }&#10;&#10;    @Override&#10;    public String getUserRole() {&#10;        return &quot;Academic&quot;;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/LibrarySystem.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/LibrarySystem.java" />
              <option name="originalContent" value="import java.util.*;&#10;&#10;public class LibrarySystem {&#10;&#10;    // The date manager is used in this assignment to provide an easier method for you to work with time logic.&#10;    // It keeps track of the current day, and allows you to progress the current day with dateManager.advanceDays(numberOfDays).&#10;    // This makes it easy for you to count overdue days, and makes it easier for you to test the system.&#10;    //&#10;    // In a real-world application, this would be replaced with a more powerful implementation of date/time logic.&#10;    private DateManager dateManager = new DateManager();&#10;    &#10;    // Collections to store library users and items&#10;    private List&lt;LibraryUser&gt; users;&#10;    private List&lt;LibraryItem&gt; libraryItems;&#10;&#10;    // Already implemented - returns access to the date manager handling the current simulated date for the library system.&#10;    public DateManager getDateManager() {&#10;        return dateManager;&#10;    }&#10;&#10;    // LibrarySystem Constructor.&#10;    public LibrarySystem() {&#10;        this.users = new ArrayList&lt;&gt;();&#10;        this.libraryItems = new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    // This method should add the specified item to the library system (or throw an exception if the item is not valid or already added).&#10;    public void addItem(LibraryItem item) {&#10;        if (item == null) {&#10;            throw new IllegalArgumentException(&quot;Item cannot be null&quot;);&#10;        }&#10;        &#10;        if (libraryItems.contains(item)) {&#10;            throw new IllegalArgumentException(&quot;Item already exists in the library system&quot;);&#10;        }&#10;        &#10;        libraryItems.add(item);&#10;    }&#10;&#10;    // This method should add a user to the library system (or throw an exception if the user is not valid or already added).&#10;    public void addUser(LibraryUser user) {&#10;        if (user == null) {&#10;            throw new IllegalArgumentException(&quot;User cannot be null&quot;);&#10;        }&#10;        &#10;        if (users.contains(user)) {&#10;            throw new IllegalArgumentException(&quot;User already exists in the library system&quot;);&#10;        }&#10;        &#10;        users.add(user);&#10;    }&#10;&#10;    // This method should loan a specific library item to a specific user. If the loan is not valid, it should throw&#10;    // an appropriate exception (e.g., it should throw LoanLimitExceededException if the user is already at their borrow limit).&#10;    public void loanItem(LibraryItem item, LibraryUser user) {&#10;        if (item == null) {&#10;            throw new IllegalArgumentException(&quot;Item cannot be null&quot;);&#10;        }&#10;        &#10;        if (user == null) {&#10;            throw new IllegalArgumentException(&quot;User cannot be null&quot;);&#10;        }&#10;        &#10;        if (!libraryItems.contains(item)) {&#10;            throw new IllegalArgumentException(&quot;Item is not in the library system&quot;);&#10;        }&#10;        &#10;        if (!users.contains(user)) {&#10;            throw new IllegalArgumentException(&quot;User is not in the library system&quot;);&#10;        }&#10;        &#10;        if (user.isSuspended()) {&#10;            throw new AccountSuspendedException(&quot;User account is suspended&quot;);&#10;        }&#10;        &#10;        if (user.isAtLoanLimit()) {&#10;            throw new LoanLimitExceededException(&quot;User has reached their loan limit&quot;);&#10;        }&#10;        &#10;        if (!item.isAvailableForLoan()) {&#10;            throw new ItemUnavailableException(&quot;Item is not available for loan&quot;);&#10;        }&#10;        &#10;        // Create and process the loan&#10;        Loan loan = new Loan(item, user, dateManager);&#10;        loan.processLoan();&#10;    }&#10;&#10;    // Returns the item to the library. This should throw an appropriate exception if the returning item is not valid.&#10;    // If the item is overdue, you do not need to write code to handle paying the fines. Assume that the fines were&#10;    // paid by the user during the return process.&#10;    public void returnItem(LibraryItem item) {&#10;        if (item == null) {&#10;            throw new IllegalArgumentException(&quot;Item cannot be null&quot;);&#10;        }&#10;        &#10;        if (!libraryItems.contains(item)) {&#10;            throw new IllegalArgumentException(&quot;Item is not in the library system&quot;);&#10;        }&#10;        &#10;        if (!item.isOnLoan()) {&#10;            throw new IllegalArgumentException(&quot;Item is not currently on loan&quot;);&#10;        }&#10;        &#10;        // Get the current loan and process the return&#10;        Loan currentLoan = item.getCurrentLoan();&#10;        if (currentLoan != null) {&#10;            currentLoan.processReturn();&#10;        }&#10;    }&#10;&#10;    // This method returns a list of all library users in the system. This method should return an unmodifiable list to prevent modification.&#10;    public List&lt;LibraryUser&gt; getUsers() {&#10;        return Collections.unmodifiableList(users);&#10;    }&#10;&#10;    // This method returns a list of all library items in the system. This method should return an unmodifiable list to prevent modification.&#10;    public List&lt;LibraryItem&gt; getLibraryItems() {&#10;        return Collections.unmodifiableList(libraryItems);&#10;    }&#10;&#10;    // This method returns a list of all library items which are currently available to be borrowed.&#10;    public List&lt;LibraryItem&gt; getBorrowableItems() {&#10;        List&lt;LibraryItem&gt; borrowableItems = new ArrayList&lt;&gt;();&#10;        for (LibraryItem item : libraryItems) {&#10;            if (item.isAvailableForLoan()) {&#10;                borrowableItems.add(item);&#10;            }&#10;        }&#10;        return Collections.unmodifiableList(borrowableItems);&#10;    }&#10;}" />
              <option name="updatedContent" value="import java.util.*;&#10;&#10;public class LibrarySystem {&#10;&#10;    // The date manager is used in this assignment to provide an easier method for you to work with time logic.&#10;    // It keeps track of the current day, and allows you to progress the current day with dateManager.advanceDays(numberOfDays).&#10;    // This makes it easy for you to count overdue days, and makes it easier for you to test the system.&#10;    //&#10;    // In a real-world application, this would be replaced with a more powerful implementation of date/time logic.&#10;    private DateManager dateManager = new DateManager();&#10;    &#10;    // Collections to store library users and items&#10;    private List&lt;LibraryUser&gt; users;&#10;    private List&lt;LibraryItem&gt; libraryItems;&#10;&#10;    // Already implemented - returns access to the date manager handling the current simulated date for the library system.&#10;    public DateManager getDateManager() {&#10;        return dateManager;&#10;    }&#10;&#10;    // LibrarySystem Constructor.&#10;    public LibrarySystem() {&#10;        this.users = new ArrayList&lt;&gt;();&#10;        this.libraryItems = new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    // This method should add the specified item to the library system (or throw an exception if the item is not valid or already added).&#10;    public void addItem(LibraryItem item) {&#10;        if (item == null) {&#10;            throw new IllegalArgumentException(&quot;Item cannot be null&quot;);&#10;        }&#10;        &#10;        if (libraryItems.contains(item)) {&#10;            throw new IllegalArgumentException(&quot;Item already exists in the library system&quot;);&#10;        }&#10;        &#10;        libraryItems.add(item);&#10;    }&#10;&#10;    // This method should add a user to the library system (or throw an exception if the user is not valid or already added).&#10;    public void addUser(LibraryUser user) {&#10;        if (user == null) {&#10;            throw new IllegalArgumentException(&quot;User cannot be null&quot;);&#10;        }&#10;        &#10;        if (users.contains(user)) {&#10;            throw new IllegalArgumentException(&quot;User already exists in the library system&quot;);&#10;        }&#10;        &#10;        users.add(user);&#10;    }&#10;&#10;    // This method should loan a specific library item to a specific user. If the loan is not valid, it should throw&#10;    // an appropriate exception (e.g., it should throw LoanLimitExceededException if the user is already at their borrow limit).&#10;    public void loanItem(LibraryItem item, LibraryUser user) {&#10;        if (item == null) {&#10;            throw new IllegalArgumentException(&quot;Item cannot be null&quot;);&#10;        }&#10;        &#10;        if (user == null) {&#10;            throw new IllegalArgumentException(&quot;User cannot be null&quot;);&#10;        }&#10;        &#10;        if (!libraryItems.contains(item)) {&#10;            throw new IllegalArgumentException(&quot;Item is not in the library system&quot;);&#10;        }&#10;        &#10;        if (!users.contains(user)) {&#10;            throw new IllegalArgumentException(&quot;User is not in the library system&quot;);&#10;        }&#10;        &#10;        if (user.isSuspended()) {&#10;            throw new AccountSuspendedException(&quot;User account is suspended&quot;);&#10;        }&#10;        &#10;        if (user.isAtLoanLimit()) {&#10;            throw new LoanLimitExceededException(&quot;User has reached their loan limit&quot;);&#10;        }&#10;        &#10;        if (!item.isAvailableForLoan()) {&#10;            throw new ItemUnavailableException(&quot;Item is not available for loan&quot;);&#10;        }&#10;        &#10;        // Create and process the loan&#10;        Loan loan = new Loan(item, user, dateManager);&#10;        loan.processLoan();&#10;    }&#10;&#10;    // Returns the item to the library. This should throw an appropriate exception if the returning item is not valid.&#10;    // If the item is overdue, you do not need to write code to handle paying the fines. Assume that the fines were&#10;    // paid by the user during the return process.&#10;    public void returnItem(LibraryItem item) {&#10;        if (item == null) {&#10;            throw new IllegalArgumentException(&quot;Item cannot be null&quot;);&#10;        }&#10;        &#10;        if (!libraryItems.contains(item)) {&#10;            throw new IllegalArgumentException(&quot;Item is not in the library system&quot;);&#10;        }&#10;        &#10;        if (!item.isOnLoan()) {&#10;            throw new IllegalArgumentException(&quot;Item is not currently on loan&quot;);&#10;        }&#10;        &#10;        // Get the current loan and process the return&#10;        Loan currentLoan = item.getCurrentLoan();&#10;        if (currentLoan != null) {&#10;            currentLoan.processReturn();&#10;        }&#10;    }&#10;&#10;    // This method returns a list of all library users in the system. This method should return an unmodifiable list to prevent modification.&#10;    public List&lt;LibraryUser&gt; getUsers() {&#10;        return Collections.unmodifiableList(users);&#10;    }&#10;&#10;    // This method returns a list of all library items in the system. This method should return an unmodifiable list to prevent modification.&#10;    public List&lt;LibraryItem&gt; getLibraryItems() {&#10;        return Collections.unmodifiableList(libraryItems);&#10;    }&#10;&#10;    // This method returns a list of all library items which are currently available to be borrowed.&#10;    public List&lt;LibraryItem&gt; getBorrowableItems() {&#10;        List&lt;LibraryItem&gt; borrowableItems = new ArrayList&lt;&gt;();&#10;        for (LibraryItem item : libraryItems) {&#10;            if (item.isAvailableForLoan()) {&#10;                borrowableItems.add(item);&#10;            }&#10;        }&#10;        return Collections.unmodifiableList(borrowableItems);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/LibraryUser.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/LibraryUser.java" />
              <option name="originalContent" value="import java.util.*;&#10;&#10;public abstract class LibraryUser {&#10;    &#10;    private String name;&#10;    private List&lt;Loan&gt; loans;&#10;&#10;    // LibraryUser Constructor&#10;    public LibraryUser (String name) {&#10;        setName(name);&#10;        this.loans = new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    // Setter for the user's name. Should throw an appropriate exception if the name is not valid.&#10;    public void setName(String name) {&#10;        if (name == null || name.trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Name cannot be null or empty&quot;);&#10;        }&#10;        this.name = name.trim();&#10;    }&#10;&#10;    // Getter method for the user's name.&#10;    public String getName() {&#10;        return name;&#10;    }&#10;&#10;    // Assigns the specified loan to the user. This method should perform appropriate validation checks to ensure that&#10;    // the loan is valid for the user, and throw appropriate exceptions as needed.&#10;    public void assignLoan(Loan loan) {&#10;        if (loan == null) {&#10;            throw new IllegalArgumentException(&quot;Loan cannot be null&quot;);&#10;        }&#10;        &#10;        if (loans.contains(loan)) {&#10;            throw new IllegalArgumentException(&quot;Loan already assigned to this user&quot;);&#10;        }&#10;        &#10;        if (isAtLoanLimit()) {&#10;            throw new LoanLimitExceededException(&quot;User has reached their loan limit&quot;);&#10;        }&#10;        &#10;        if (isSuspended()) {&#10;            throw new AccountSuspendedException(&quot;User account is suspended due to excessive fines&quot;);&#10;        }&#10;        &#10;        loans.add(loan);&#10;    }&#10;&#10;    // Removes the specified loan from the user. Should throw an appropriate exception if the loan is not valid.&#10;    public void removeLoan(Loan loan) {&#10;        if (loan == null) {&#10;            throw new IllegalArgumentException(&quot;Loan cannot be null&quot;);&#10;        }&#10;        &#10;        if (!loans.contains(loan)) {&#10;            throw new IllegalArgumentException(&quot;Loan is not assigned to this user&quot;);&#10;        }&#10;        &#10;        loans.remove(loan);&#10;    }&#10;&#10;    // Returns true if the user's current fine total equals or exceeds their suspension limit.&#10;    public boolean isSuspended () {&#10;        return getTotalFines() &gt;= getFineSuspensionLimit();&#10;    }&#10;&#10;    // Returns a list of loans currently active for the user.&#10;    // This should be an unmodifiable list to prevent unexpected modification.&#10;    public List&lt;Loan&gt; getLoans () {&#10;        return Collections.unmodifiableList(loans);&#10;    }&#10;&#10;    // Returns the total amount of fines that the user has accrued.&#10;    public double getTotalFines() {&#10;        double totalFines = 0.0;&#10;        for (Loan loan : loans) {&#10;            totalFines += loan.getLoanFine();&#10;        }&#10;        return totalFines;&#10;    }&#10;&#10;    // Returns true if the user is already at their loan limit and cannot borrow more items.&#10;    public boolean isAtLoanLimit () {&#10;        return loans.size() &gt;= getLoanLimit();&#10;    }&#10;&#10;    // Abstract methods that must be implemented by subclasses&#10;    public abstract int getLoanLimit();&#10;    public abstract int getLoanPeriodForItem(LibraryItem item);&#10;    public abstract double getFineRateModifier();&#10;    public abstract double getFineSuspensionLimit();&#10;    public abstract String getUserRole();&#10;}" />
              <option name="updatedContent" value="import java.util.*;&#10;&#10;public abstract class LibraryUser {&#10;    &#10;    private String name;&#10;    private List&lt;Loan&gt; loans;&#10;&#10;    // LibraryUser Constructor&#10;    public LibraryUser (String name) {&#10;        setName(name);&#10;        this.loans = new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    // Setter for the user's name. Should throw an appropriate exception if the name is not valid.&#10;    public void setName(String name) {&#10;        if (name == null || name.trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Name cannot be null or empty&quot;);&#10;        }&#10;        this.name = name.trim();&#10;    }&#10;&#10;    // Getter method for the user's name.&#10;    public String getName() {&#10;        return name;&#10;    }&#10;&#10;    // Assigns the specified loan to the user. This method should perform appropriate validation checks to ensure that&#10;    // the loan is valid for the user, and throw appropriate exceptions as needed.&#10;    public void assignLoan(Loan loan) {&#10;        if (loan == null) {&#10;            throw new IllegalArgumentException(&quot;Loan cannot be null&quot;);&#10;        }&#10;        &#10;        if (loans.contains(loan)) {&#10;            throw new IllegalArgumentException(&quot;Loan already assigned to this user&quot;);&#10;        }&#10;        &#10;        if (isAtLoanLimit()) {&#10;            throw new LoanLimitExceededException(&quot;User has reached their loan limit&quot;);&#10;        }&#10;        &#10;        if (isSuspended()) {&#10;            throw new AccountSuspendedException(&quot;User account is suspended due to excessive fines&quot;);&#10;        }&#10;        &#10;        loans.add(loan);&#10;    }&#10;&#10;    // Removes the specified loan from the user. Should throw an appropriate exception if the loan is not valid.&#10;    public void removeLoan(Loan loan) {&#10;        if (loan == null) {&#10;            throw new IllegalArgumentException(&quot;Loan cannot be null&quot;);&#10;        }&#10;        &#10;        if (!loans.contains(loan)) {&#10;            throw new IllegalArgumentException(&quot;Loan is not assigned to this user&quot;);&#10;        }&#10;        &#10;        loans.remove(loan);&#10;    }&#10;&#10;    // Returns true if the user's current fine total equals or exceeds their suspension limit.&#10;    public boolean isSuspended () {&#10;        return getTotalFines() &gt;= getFineSuspensionLimit();&#10;    }&#10;&#10;    // Returns a list of loans currently active for the user.&#10;    // This should be an unmodifiable list to prevent unexpected modification.&#10;    public List&lt;Loan&gt; getLoans () {&#10;        return Collections.unmodifiableList(loans);&#10;    }&#10;&#10;    // Returns the total amount of fines that the user has accrued.&#10;    public double getTotalFines() {&#10;        double totalFines = 0.0;&#10;        for (Loan loan : loans) {&#10;            totalFines += loan.getLoanFine();&#10;        }&#10;        return totalFines;&#10;    }&#10;&#10;    // Returns true if the user is already at their loan limit and cannot borrow more items.&#10;    public boolean isAtLoanLimit () {&#10;        return loans.size() &gt;= getLoanLimit();&#10;    }&#10;&#10;    // Abstract methods that must be implemented by subclasses&#10;    public abstract int getLoanLimit();&#10;    public abstract int getLoanPeriodForItem(LibraryItem item);&#10;    public abstract double getFineRateModifier();&#10;    public abstract double getFineSuspensionLimit();&#10;    public abstract String getUserRole();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>